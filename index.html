<!DOCTYPE html>
<html>
<!--
    todo: emoji shader
    todo: scene hash uniform
-->

<head>
    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script> -->
    <style type="text/css">
        html,
        body {
            margin: 0;
            padding: 0;
            border: 0;
            width: 100%;
            height: 100%;
            font-family: sans-serif;
        }

        body {
            background-color: black;
        }

        #canvas {
            background-color: black;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            border: 0;
        }

        #butan {
            position: absolute;
            top: 0;
            left: 0;
            color: #6b5d92;
            text-shadow: -2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black;
            text-decoration: none;
            cursor: pointer;
            font-size: 20px;
            border-radius: 9px;
            border: 3px solid #666;
            padding: 4px;
            padding-left: 12px;
            padding-right: 12px;
            background-color: #222;
            margin-top: 8px;
            margin-left: 8px;
        }

        #footer {
            position: absolute;
            bottom: 6px;
            left: 0;
            width: 100vw;
            text-align: right;
            font-size: 18px;
            text-shadow:
                -2px -2px 0 black,
                2px -2px 0 black,
                -2px 2px 0 black,
                2px 2px 0 black;
        }

        #footer,
        a,
        a:visited,
        a:link,
        a:hover {
            color: #6b5d92;
            text-shadow:
                -2px -2px 0 black,
                2px -2px 0 black,
                -2px 2px 0 black,
                2px 2px 0 black;
            text-decoration: none;
        }

        #shaderMenu {
            position: absolute;
            top: 10px;
            right: 10px;
            max-height: 90vh;
            border-radius: 9px;
            border: 3px solid #666;
            padding: 4px;
            padding-left: 12px;
            padding-right: 12px;
            background-color: #222;
            margin-top: 8px;
            margin-left: 8px;
        }

        #shaderMenu ul {
            margin: 0;
            margin-block: unset;
            list-style-type: none;
            padding-block: unset;
            margin-inline: unset;
            padding-inline: unset;
        }

        #shaderMenu li {
            color: #6b5d92;
            text-shadow: -2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black;
            text-decoration: none;
            cursor: pointer;
            font-size: 20px;

            list-style-type: none;
            margin: 0;
        }


        #shaderMenu li:hover {
            color: #8f7cc2;
            background-color: #444;
        }

        #shaderMenu li.selected {
            color: #c2b9da;
            text-shadow: -2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black;
        }
        #shaderMenu li.random {
            color: #666;
            margin-bottom:12px;
        }
    </style>
</head>

<body>
    <canvas id="canvas" onclick="canvasClick()"></canvas>
    <!-- <div style="position:absolute;top:0;left:0;color:white;font-size: 24px;" id="log">hi</div> -->
    <div id="butan" onclick="OnSeedButtonClick()"></div>
    <div id="shaderMenu">
        <ul id="shaderMenuList">
            <!-- <li onclick="gotoShader('badHotelArtwork')">bad hotel artwork</li> -->
        </ul>
    </div>
    <div id="footer"><a href="https://twitter.com/tenfour2">who made this??</a></div>

    <script id="vertexShader" type="x-shader/x-vertex">#version 300 es
        precision lowp float;
        in vec4 position;
        void main() {
            gl_Position = position;
          }
                </script>

    <script type="text/javascript">

        var loadShader = function (gl, shaderSource, shaderType) {
            var shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            // Check the compile status
            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compiled) {
                // Something went wrong during compilation; get the error
                lastError = gl.getShaderInfoLog(shader);
                console.log("*** Error compiling shader '" + shader + "':" + lastError);
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        var loadProgram = function (gl, shaders, opt_attribs, opt_locations) {
            var program = gl.createProgram();
            for (var ii = 0; ii < shaders.length; ++ii) {
                gl.attachShader(program, shaders[ii]);
            }
            if (opt_attribs) {
                for (var ii = 0; ii < opt_attribs.length; ++ii) {
                    gl.bindAttribLocation(
                        program,
                        opt_locations ? opt_locations[ii] : ii,
                        opt_attribs[ii]);
                }
            }
            gl.linkProgram(program);

            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                lastError = gl.getProgramInfoLog(program);
                console.log("Error in program linking:" + lastError);
                gl.deleteProgram(program);
                return null;
            }
            return program;
        };

        const resources = [
            // more state is held here after resource load & gl init
            { uri: 'badHotelArtwork.glsl', type: "text" },
            { uri: 'glitch7.glsl', type: "text" },
            { uri: 'shardLaundry.glsl', type: "text" },
            { uri: 'bayer8x8.png', type: "image" },
        ];

        const textures = [
            { uri: 'bayer8x8.png' },
        ];

        const apps = [
            {
                id: "badHotelArtwork",
                title: "bad hotel artwork generator",
                fragShaderURI: 'badHotelArtwork.glsl',
                // more state is held here after resource load & gl init
            },
            {
                id: "glitch7",
                title: "glitch#7",
                fragShaderURI: 'glitch7.glsl',
                // more state is held here after resource load & gl init
            },
            {
                id: "shardLaundry",
                title: "shard laundry",
                fragShaderURI: 'shardLaundry.glsl',
                texture0: 'bayer8x8.png',
                // more state is held here after resource load & gl init
            },
        ];

        let gSceneCell;
        let gShaderID;

        const canvas = document.getElementById("canvas");
        const gl = canvas.getContext("webgl2");
        const gVertexShader = loadShader(gl, document.getElementById('vertexShader').text, gl.VERTEX_SHADER);

        let mousePos = { x: 0, y: 0 };

        function GenerateSeed() {
            return Math.floor(Math.random() * 10000); // hash42 does not like large seeds.
        }

        function SwitchToSeed(seed, shouldReplaceInsteadOfPush) {
            gSceneCell = seed;
            gSceneHash = [.2, .3, .4, .5];
            document.getElementById('butan').innerText = "Seed #" + gSceneCell;
            const url = new URL(window.location);
            url.searchParams.set('seed', gSceneCell);
            url.searchParams.set('shader', gShaderID);
            if (shouldReplaceInsteadOfPush) {
                window.history.replaceState({ seed: gSceneCell, shader: gShaderID }, '', url);
            } else {
                window.history.pushState({ seed: gSceneCell, shader: gShaderID }, '', url);
            }
        }

        window.onpopstate = function (e) {
            if (e.state) {
                if (e.state.seed) {
                    gSceneCell = e.state.seed;
                    document.getElementById('butan').innerText = "Seed #" + gSceneCell;
                }
                if (e.state.shader) {
                    SwitchToShader(e.state.shader);
                }

            }
        };

        var gPlaying = true;
        var gStartTime = Date.now();
        var gPauseStartTime;
        var gPauseTime = 0; // in order to support pause/play.

        function OnSeedButtonClick() {
            SwitchToSeed(GenerateSeed());
        }

        function canvasClick() {
            if (gPlaying) {
                gPauseStartTime = Date.now();
            } else {
                gStartTime += gPauseTime;
                gPauseTime = 0;
            }
            gPlaying = !gPlaying;
        }

        let resolution = { x: 0, y: 0 };
        gl.canvas.width = resolution.x = gl.canvas.clientWidth;
        gl.canvas.height = resolution.y = gl.canvas.clientHeight;

        canvas.addEventListener('mousemove', event => {
            let bound = canvas.getBoundingClientRect();
            mousePos.x = event.clientX - bound.left - canvas.clientLeft;
            mousePos.y = event.clientY - bound.top - canvas.clientTop;
        });

        function SwitchToShader(id, shouldReplaceInsteadOfPush) {
            gShaderID = id;
            var app = apps.find(a => a.id == gShaderID);
            if (!app) {
                app = apps[0];
                gShaderID = app.id;
            }
            for (var i = 0; i < apps.length; ++i) {
                apps[i].menuItem.classList.remove('selected');
            }
            app.menuItem.classList.add('selected');
            document.title = app.title;

            const url = new URL(window.location);
            url.searchParams.set('seed', gSceneCell);
            url.searchParams.set('shader', gShaderID);
            if (shouldReplaceInsteadOfPush) {
                window.history.replaceState({ seed: gSceneCell, shader: gShaderID }, '', url);
            } else {
                window.history.pushState({ seed: gSceneCell, shader: gShaderID }, '', url);
            }

            gl.useProgram(app.program);

            var buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array([
                    -1.0, -1.0,
                    1.0, -1.0,
                    -1.0, 1.0,
                    -1.0, 1.0,
                    1.0, -1.0,
                    1.0, 1.0]),
                gl.STATIC_DRAW);
            gl.enableVertexAttribArray(app.positionLocation);
            gl.vertexAttribPointer(app.positionLocation, 2, gl.FLOAT, false, 0, 0);
        }

        // init shader menu
        var randomness = document.createElement("li");
        randomness.innerText = "<random>";
        randomness.classList.add("random");
        randomness.addEventListener('click', () => {
            var index = Math.floor(Math.random() * apps.length) % apps.length;
            SwitchToShader(apps[index].id, true);
            SwitchToSeed(GenerateSeed());
        });
        document.getElementById("shaderMenuList").appendChild(randomness);

        for (var i = 0; i < apps.length; ++i) {
            const app = apps[i];
            app.menuItem = document.createElement("li");
            app.menuItem.innerText = app.title;
            app.menuItem.addEventListener('click', () => {
                SwitchToShader(app.id);
            });
            document.getElementById("shaderMenuList").appendChild(app.menuItem);
        };

        const drawScene = function () {
            var app = apps.find(a => a.id == gShaderID);
            if (gl.canvas.clientHeight != resolution.y || gl.canvas.clientWidth != resolution.x) {
                gl.canvas.width = resolution.x = gl.canvas.clientWidth;
                gl.canvas.height = resolution.y = gl.canvas.clientHeight;
            }
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.uniform2f(app.resolutionLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform2f(app.mouseLocation, mousePos.x, mousePos.y);
            if (!gPlaying) {
                gPauseTime = Date.now() - gPauseStartTime;
            }
            gl.uniform1f(app.timeLocation, (Date.now() - gStartTime - gPauseTime) / 1000);
            gl.uniform1f(app.sceneLocation, gSceneCell);
            gl.uniform4fv(app.sceneHashLocation, gSceneHash);

            if (app.texture0) {
                var t = textures.find(t => t.uri == app.texture0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, t.texture);
                gl.uniform1i(app.iChannel0, 0);
            }

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        };

        const gDoAnimFrame = function () {
            requestAnimationFrame(() => { gDoAnimFrame(); });
            drawScene();
        };

        const GetLoadedResource = (uri) => {
            return resources.find(r => r.uri == uri);
        }

        const OnAllResourcesLoaded = () => {
            //console.log("OnAllResourcesLoaded");
            apps.forEach(app => {
                app.fragmentShader = loadShader(gl, GetLoadedResource(app.fragShaderURI).xhr.responseText, gl.FRAGMENT_SHADER);
                app.program = loadProgram(gl, [gVertexShader, app.fragmentShader]);
                app.positionLocation = gl.getAttribLocation(app.program, "position");
                app.resolutionLocation = gl.getUniformLocation(app.program, "iResolution");
                app.timeLocation = gl.getUniformLocation(app.program, "iTime");
                app.mouseLocation = gl.getUniformLocation(app.program, "iMouse");
                app.sceneLocation = gl.getUniformLocation(app.program, "sceneCell");
                app.sceneHashLocation = gl.getUniformLocation(app.program, "iSceneHash");
                app.iChannel0 = gl.getUniformLocation(app.program, 'iChannel0');
                app.iChannel1 = gl.getUniformLocation(app.program, 'iChannel1');
                app.iChannel2 = gl.getUniformLocation(app.program, 'iChannel2');
                app.iChannel3 = gl.getUniformLocation(app.program, 'iChannel3');
            });

            textures.forEach(tex => {
                var res = GetLoadedResource(tex.uri);
                tex.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                    gl.RGBA, gl.UNSIGNED_BYTE, res.image);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            });

            const args = Object.fromEntries([...new URLSearchParams(location.search)]);

            var selectedAppID = args['shader'];
            if (selectedAppID && apps.find(a => a.id == selectedAppID)) {
                SwitchToShader(selectedAppID, true);
            } else {
                var index = Math.floor(Math.random() * apps.length) % apps.length;
                SwitchToShader(apps[index].id, true);
            }

            var selectedSeed = parseInt(args.seed) % 10000;
            if (!isNaN(selectedSeed)) {
                SwitchToSeed(selectedSeed, true);
            } else {
                SwitchToSeed(GenerateSeed(), true);
            }

            gDoAnimFrame();
        };

        let loadedCount = 0;

        resources.forEach(res => {
            if (res.type == "text") {
                res.xhr = new XMLHttpRequest();
                res.xhr.open('GET', res.uri + "?x=" + (Date.now()), true);
                res.xhr.responseType = "text";
                res.xhr.onload = e => {
                    if (res.xhr.readyState == 4) {
                        //console.log("Loaded " + res.uri);
                        loadedCount++;
                        if (loadedCount == resources.length) {
                            OnAllResourcesLoaded();
                        }
                    }
                };
                res.xhr.send();
            } else if (res.type == "image") {
                res.image = new Image();
                res.image.onload = () => {
                    //console.log("Loaded " + res.uri);
                    loadedCount++;
                    if (loadedCount == resources.length) {
                        OnAllResourcesLoaded();
                    }
                };
                res.image.src = res.uri
            }
        });


    </script>

</body>

</html>